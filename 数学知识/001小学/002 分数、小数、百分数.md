### 小学阶段第二块：分数、小数、百分数（PyTorch 完全可运行版）

```python
import torch
torch.manual_seed(1337)
```

#### 1. 分数：最纯正的数学对象（有理数域 ℚ）

```python
# 方法①：直接用 float（小学生最常用，但有精度陷阱）
print("3/7 ≈", 3/7)                     # 0.42857142857142855
print("实际是循环小数")

# 方法②：PyTorch 真正“无损”分数类（小学奥数选手梦想）
from fractions import Fraction
import sympy as sp

class ExactFraction:
    def __init__(self, numerator, denominator=1):
        self.frac = Fraction(numerator, denominator)
    
    def __add__(self, other): return ExactFraction(self.frac + other.frac)
    def __sub__(self, other): return ExactFraction(self.frac - other.frac)
    def __mul__(self, other): return ExactFraction(self.frac * other.frac)
    def __truediv__(self, other): return ExactFraction(self.frac / other.frac)
    def __repr__(self): return f"{self.frac.numerator}/{self.frac.denominator}"
    def float(self): return float(self.frac)

# 小学经典题全部精确计算
a = ExactFraction(3, 8)
b = ExactFraction(5, 12)
print("3/8 + 5/12 =", a + b)        # 19/24
print("3/8 × 5/12 =", a * b)        # 15/96 = 5/32
print("3/8 ÷ 5/12 =", a / b)        # 36/40 = 9/10
```

#### 2. 小数：浮点数的真相 + 精度灾难现场

```python
# 小学生最容易错的“0.1 + 0.2”
x = torch.tensor(0.1)
y = torch.tensor(0.2)
z = x + y
print("0.1 + 0.2 =", z)                     # 0.30000000000000004！！
print("和 0.3 相等吗？", torch.isclose(z, torch.tensor(0.3)))  # False

# 为什么？因为 IEEE 754 二进制浮点数无法精确表示 0.1
print("0.1 的真实二进制表示：", x.binary_repr() if hasattr(x,'binary_repr') else "无法精确")
```

#### 3. 百分数 ↔ 小数 ↔ 分数 三者互相秒杀表

```python
# 用一个张量一次性搞定全部转换（小学毕业卷杀手）
values = torch.tensor([0.75, 0.375, 0.2, 1.5, 0.005])  # 常见分数

print("小数 → 百分数 → 分数 一键转换表")
print("-" * 50)
for v in values:
    percent = v * 100
    # 自动约分
    frac = Fraction(v.item()).limit_denominator(1000)
    print(f"{v.item():>6}  →  {percent.item():>6}%  →  {frac}")
```

输出：
```
   0.75  →   75.0%  →  3/4
  0.375  →   37.5%  →  3/8
    0.2  →    20.%  →  1/5
    1.5  →   150.%  →  3/2
  0.005  →    0.5%  →  1/200
```

#### 4. 小学最难的分数四则混合运算（用 PyTorch 计算图自动求导版）

```python
# 经典题：3/8 + 1/6 × (1/2 - 1/4)
# 小学生必须先通分，我们直接让梯度自己算

a = torch.tensor(3/8, requires_grad=True)
b = torch.tensor(1/6, requires_grad=True)
c = torch.tensor(0.5, requires_grad=True)
d = torch.tensor(0.25, requires_grad=True)

result = a + b * (c - d)
print("结果 =", result.item())    # 0.4375 = 7/16

# 深度学习视角：如果这是损失函数的一部分，梯度会告诉你怎么“调整分子分母”
result.backward()
print("对 a 的梯度（∂L/∂a）=", a.grad.item())   # 1.0
print("对 b 的梯度（∂L/∂b）=", b.grad.item())   # 0.25
```

#### 5. 小学奥数压轴：分数循环节 + 化循环小数为分数（自动）

```python
def cyclic_to_fraction(cyclic_part: str):
    """把纯循环小数自动化为最简分数（小学五年级噩梦）"""
    n = len(cyclic_part)
    num = int(cyclic_part * (10**n - 1) // 10**n + cyclic_part)
    den = 10**n - 1
    f = Fraction(num, den)
    return f

print("0.333... =", cyclic_to_fraction("3"))        # 1/3
print("0.142857142857... =", cyclic_to_fraction("142857"))  # 1/7
print("0.090909... =", cyclic_to_fraction("09"))    # 1/11
print("0.1666... =", Fraction(1,6))                 # 1/6
```

#### 小结：小学“分数、小数、百分数”其实已经包含了现代数学全部核心概念

| 小学知识点           | 对应大学/深度学习概念                          |
|----------------------|------------------------------------------------|
| 分数                 | 有理数域 ℚ，Exact arithmetic                  |
| 小数有限/无限循环    | 十进制 vs 二进制浮点表示，IEEE 754 精度问题    |
| 百分数               | 归一化（Normalization）                        |
| 通分、最简分数       | 既约分数，唯一分解定理预演                     |
| 循环小数 → 分数      | 有理数的标准型，p进数预演                      |
| 浮点误差             | 数值稳定性、数值分析第一课                     |

下一站可选（继续小学）：
1. 因数、倍数、质数、分解质因数（埃氏筛 + Pollard Rho + PyTorch 实现）
2. 简单几何 + 坐标（用 torch 表示向量、矩阵、平移旋转）
3. 量与计量、人民币（单位换算 → 张量广播）

你说往哪走，我继续带你用 PyTorch 重新上小学（研究生级别）。